/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package reclassification;

import au.com.bytecode.opencsv.CSVReader;
import au.com.bytecode.opencsv.CSVWriter;
import com.sdmetrics.model.MetaModel;
import com.sdmetrics.model.MetaModelElement;
import com.sdmetrics.model.Model;
import com.sdmetrics.model.ModelElement;
import com.sdmetrics.model.XMIReader;
import com.sdmetrics.model.XMITransformations;
import com.sdmetrics.util.XMLParser;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.Action;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.filechooser.FileFilter;
import reclassification.util.XMIMetricsExtractor;
import reclassification.util.XMIVersionExtractor;

/**
 *
 * @author aislimau
 */
public class FeatureExtractor extends javax.swing.JFrame {

    /**
     * Creates new form TextExtractor
     */
    
    protected String xmiFileStr = "";

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonGroup1 = new javax.swing.ButtonGroup();
        textPanel = new javax.swing.JPanel();
        fullClassnameText = new javax.swing.JScrollPane();
        metricsDisplay = new javax.swing.JTextArea();
        jScrollPane1 = new javax.swing.JScrollPane();
        extractAttributes = new javax.swing.JTextArea();
        listMetrics = new javax.swing.JButton();
        readCSV = new javax.swing.JButton();
        btnListMetrics = new javax.swing.JButton();
        xmiFilename = new javax.swing.JTextField();
        chooseFileBtn = new javax.swing.JButton();
        readClassMetrics = new javax.swing.JButton();
        csvFileName = new javax.swing.JTextField();
        csvFile = new javax.swing.JButton();
        saveText = new javax.swing.JButton();
        clearBtn = new javax.swing.JButton();
        jButton1 = new javax.swing.JButton();
        umlVersionSel = new javax.swing.JComboBox();
        xmiVerSel = new javax.swing.JComboBox();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        menuBar = new javax.swing.JMenuBar();
        fileMenu = new javax.swing.JMenu();
        openMenuItem = new javax.swing.JMenuItem();
        saveMenuItem = new javax.swing.JMenuItem();
        saveAsMenuItem = new javax.swing.JMenuItem();
        exitMenuItem = new javax.swing.JMenuItem();
        editMenu = new javax.swing.JMenu();
        cutMenuItem = new javax.swing.JMenuItem();
        copyMenuItem = new javax.swing.JMenuItem();
        pasteMenuItem = new javax.swing.JMenuItem();
        deleteMenuItem = new javax.swing.JMenuItem();
        helpMenu = new javax.swing.JMenu();
        contentsMenuItem = new javax.swing.JMenuItem();
        aboutMenuItem = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        metricsDisplay.setColumns(20);
        metricsDisplay.setLineWrap(true);
        metricsDisplay.setRows(5);
        metricsDisplay.setAutoscrolls(false);
        fullClassnameText.setViewportView(metricsDisplay);

        extractAttributes.setColumns(20);
        extractAttributes.setLineWrap(true);
        extractAttributes.setRows(5);
        extractAttributes.setAutoscrolls(false);
        jScrollPane1.setViewportView(extractAttributes);

        listMetrics.setText("List of Metrics");
        listMetrics.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                listMetricsActionPerformed(evt);
            }
        });

        readCSV.setText("Read CSV");

        btnListMetrics.setText("List Metrics");
        btnListMetrics.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnListMetricsActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout textPanelLayout = new javax.swing.GroupLayout(textPanel);
        textPanel.setLayout(textPanelLayout);
        textPanelLayout.setHorizontalGroup(
            textPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(textPanelLayout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(textPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(textPanelLayout.createSequentialGroup()
                        .addComponent(listMetrics)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnListMetrics))
                    .addComponent(fullClassnameText, javax.swing.GroupLayout.PREFERRED_SIZE, 383, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(textPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(readCSV)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 368, javax.swing.GroupLayout.PREFERRED_SIZE)))
        );
        textPanelLayout.setVerticalGroup(
            textPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(textPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(textPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 259, Short.MAX_VALUE)
                    .addComponent(fullClassnameText))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(textPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(listMetrics)
                    .addComponent(readCSV)
                    .addComponent(btnListMetrics))
                .addContainerGap())
        );

        xmiFilename.setText("C:\\Users\\aisli_000\\Documents\\NetBeansProjects\\REClassification\\XMIs\\version1\\Version1_XMI2_1_UML2_0.xmi");
        xmiFilename.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                xmiFilenameActionPerformed(evt);
            }
        });

        chooseFileBtn.setText("Select XMI File");
        chooseFileBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                chooseFileBtnActionPerformed(evt);
            }
        });

        readClassMetrics.setText("Read Class Metrics");
        readClassMetrics.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                readClassMetricsActionPerformed(evt);
            }
        });

        csvFileName.setText("/Users/truongh/Documents/TruongHQ-Projects/Non_shared/2017.REDvsFWD/XMIExtractor/REClassification/data_Class.csv");
        csvFileName.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                csvFileNameActionPerformed(evt);
            }
        });

        csvFile.setText("Select CSV File");
        csvFile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                csvFileActionPerformed(evt);
            }
        });

        saveText.setText("Save Text");
        saveText.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveTextActionPerformed(evt);
            }
        });

        clearBtn.setText("Clear");
        clearBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                clearBtnActionPerformed(evt);
            }
        });

        jButton1.setText("jButton1");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        umlVersionSel.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "UML 1.x", "UML 2.x" }));
        umlVersionSel.setEnabled(false);
        umlVersionSel.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                umlVersionSelActionPerformed(evt);
            }
        });

        xmiVerSel.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "XMI 1.0", "XMI 1.x", "XMI 2.0-2.1" }));
        xmiVerSel.setEnabled(false);

        jLabel1.setText("UML version");

        jLabel2.setText("XMI version");

        fileMenu.setMnemonic('f');
        fileMenu.setText("File");

        openMenuItem.setMnemonic('o');
        openMenuItem.setText("Open");
        fileMenu.add(openMenuItem);

        saveMenuItem.setMnemonic('s');
        saveMenuItem.setText("Save");
        fileMenu.add(saveMenuItem);

        saveAsMenuItem.setMnemonic('a');
        saveAsMenuItem.setText("Save As ...");
        saveAsMenuItem.setDisplayedMnemonicIndex(5);
        fileMenu.add(saveAsMenuItem);

        exitMenuItem.setMnemonic('x');
        exitMenuItem.setText("Exit");
        exitMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exitMenuItemActionPerformed(evt);
            }
        });
        fileMenu.add(exitMenuItem);

        menuBar.add(fileMenu);

        editMenu.setMnemonic('e');
        editMenu.setText("Edit");

        cutMenuItem.setMnemonic('t');
        cutMenuItem.setText("Cut");
        editMenu.add(cutMenuItem);

        copyMenuItem.setMnemonic('y');
        copyMenuItem.setText("Copy");
        editMenu.add(copyMenuItem);

        pasteMenuItem.setMnemonic('p');
        pasteMenuItem.setText("Paste");
        editMenu.add(pasteMenuItem);

        deleteMenuItem.setMnemonic('d');
        deleteMenuItem.setText("Delete");
        editMenu.add(deleteMenuItem);

        menuBar.add(editMenu);

        helpMenu.setMnemonic('h');
        helpMenu.setText("Help");

        contentsMenuItem.setMnemonic('c');
        contentsMenuItem.setText("Contents");
        helpMenu.add(contentsMenuItem);

        aboutMenuItem.setMnemonic('a');
        aboutMenuItem.setText("About");
        helpMenu.add(aboutMenuItem);

        menuBar.add(helpMenu);

        setJMenuBar(menuBar);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addComponent(textPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(89, 89, 89))
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(20, 20, 20)
                        .addComponent(readClassMetrics)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(saveText)
                        .addGap(91, 91, 91)
                        .addComponent(clearBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 86, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton1))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(26, 26, 26)
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(umlVersionSel, javax.swing.GroupLayout.PREFERRED_SIZE, 92, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(45, 45, 45)
                        .addComponent(jLabel2)
                        .addGap(18, 18, 18)
                        .addComponent(xmiVerSel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addGroup(layout.createSequentialGroup()
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(xmiFilename)
                    .addComponent(csvFileName, javax.swing.GroupLayout.PREFERRED_SIZE, 1, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(chooseFileBtn, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(csvFile, javax.swing.GroupLayout.PREFERRED_SIZE, 1, Short.MAX_VALUE))
                .addGap(80, 80, 80))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(xmiFilename)
                    .addComponent(chooseFileBtn, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(csvFileName, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(csvFile))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(umlVersionSel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(xmiVerSel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel1)
                    .addComponent(jLabel2))
                .addGap(21, 21, 21)
                .addComponent(textPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(readClassMetrics)
                    .addComponent(saveText)
                    .addComponent(clearBtn)
                    .addComponent(jButton1))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    public FeatureExtractor (){
        initComponents();
    }
    
    class csvExtendName extends javax.swing.filechooser.FileFilter {
        @Override
        public boolean accept(File file) {
            // Allow only directories, or files with ".txt" extension
            return file.isDirectory() || file.getAbsolutePath().endsWith(".csv") 
                    || file.getAbsolutePath().endsWith(".xls") 
                    || file.getAbsolutePath().endsWith(".xlsx");
        }
        
        @Override
        public String getDescription() {
            // This description will be displayed in the dialog,
            // hard-coded = ugly, should be done via I18N
            return "CSV files (*.csv/xls/xlsx)";
        }
    } 
    
    class xmiExtendName extends javax.swing.filechooser.FileFilter {
        @Override
        public boolean accept(File file) {
            // Allow only directories, or files with ".txt" extension
            return file.isDirectory() || file.getAbsolutePath().endsWith(".txt") 
                    || file.getAbsolutePath().endsWith(".xml") 
                    || file.getAbsolutePath().endsWith(".xmi");
        }
        
        @Override
        public String getDescription() {
            // This description will be displayed in the dialog,
            // hard-coded = ugly, should be done via I18N
            return "XMI files (*.xmi/xml/txt)";
        }
    }
        
    class textExtendName extends javax.swing.filechooser.FileFilter {
        @Override
        public boolean accept(File file) {
            // Allow only directories, or files with ".txt" extension
            return file.isDirectory() || file.getAbsolutePath().endsWith(".txt") 
                    || file.getAbsolutePath().endsWith(".xml") 
                    || file.getAbsolutePath().endsWith(".xmi");
        }
        
        @Override
        public String getDescription() {
            // This description will be displayed in the dialog,
            // hard-coded = ugly, should be done via I18N
            return "Text files (*.txt/xml/xmi)";
        }
    }  
        
    private void exitMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exitMenuItemActionPerformed
        System.exit(0);
    }//GEN-LAST:event_exitMenuItemActionPerformed

    /** This is a substitute for FileNameExtensionFilter, which is
     * only available on Java SE 6.
     */
     
    private void chooseFileBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_chooseFileBtnActionPerformed
    
        String [] row = null;
        FileFilter filters;
        JFileChooser fileChooser = new JFileChooser();
            
        filters = new xmiExtendName();
        fileChooser.setFileFilter(filters);
        int returnVal = fileChooser.showOpenDialog(this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            xmiFileStr = "";
            File xmiFile = fileChooser.getSelectedFile();           
            xmiFileStr = xmiFile.getAbsolutePath();
            xmiFilename.setText(xmiFileStr);
            System.out.println("File " + xmiFile.getName() + " is successfully loaded!");
        } else {
                System.out.println("File access cancelled by user.");
                }     
    }//GEN-LAST:event_chooseFileBtnActionPerformed

    private void csvFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_csvFileActionPerformed
        // TODO add your handling code here:
        String [] row = null;
        String csvFileStr = "";
        FileFilter filters;
        JFileChooser fileChooser = new JFileChooser();
            
        filters = new csvExtendName();
        fileChooser.setFileFilter(filters);
        int returnVal = fileChooser.showOpenDialog(this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            csvFileStr = "";
            File file = fileChooser.getSelectedFile();           
            csvFileStr = file.getAbsolutePath();
            csvFileName.setText(csvFileStr);
        } else {
                System.out.println("File access cancelled by user.");
                }     
    }//GEN-LAST:event_csvFileActionPerformed

/* Read from .CSV file    
//    private void readCSVActionPerformed(java.awt.event.ActionEvent evt) {                                        
//   
//        int count = 0;
//        int noClasses = 0;
//        int noAttr = 0;
//        int noOps = 0;
//        int noECPar = 0;
//        int noICPar = 0;
//        float avgAttrCls = 0;
//        float avgOpsCls = 0;
//        int noDepOut = 0;
//        int noDepIn = 0;
//        int maxNumOps = 0;
//        String xmiFile = "";
//        CSVReader csvReader = null;
//        metricsDisplay.setLineWrap(true);
//        extractAttributes.setText(null);
//        
//        String csvFilename = "";
//        xmiFile = xmiFilename.getText();
//        String [] row = null;
//        
//        classMetricsReader(xmiFile);        // generate class metrics csv
//        csvFilename = "data_class.csv";
//                
//        try {
//            List<String> classListLocal = new ArrayList<>();
//
//            if (csvFilename.isEmpty() == false) {
//                try {
//                    csvReader = new CSVReader (new FileReader(csvFilename));
//                    try {
//                        row = csvReader.readNext();
//                    } catch (IOException ex) {
//                        Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
//                    }
//                } catch (FileNotFoundException ex) {
//                    Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
//                }
//      
//            while ((row = csvReader.readNext()) != null){
//              count++;
//              noAttr = noAttr + Integer.parseInt(row[1]);
//              noOps = noOps + Integer.parseInt(row[2]);
//              if (maxNumOps < Integer.parseInt(row[2])){
//                maxNumOps = Integer.parseInt(row[2]);    
//              }
//              noDepOut = noDepOut + + Integer.parseInt(row[15]);
//              noDepIn = noDepIn + + Integer.parseInt(row[15]);
//              }                    
//            noClasses = count;
//            }
//                             
//            try {
//                csvReader.close();
//            } catch (IOException ex) {
//                Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
//                }
//            } catch (IOException ex) {
//            Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
//            }
//            
//           if (noAttr > 0 && noClasses > 0){
//               avgAttrCls = Integer.valueOf(noAttr).floatValue() / Integer.valueOf(noClasses).floatValue();  // calculate average number of attribute per class 
//            }
//            
//            if (noClasses > 0 && noOps > 0){
//               avgOpsCls = Integer.valueOf(noOps).floatValue() / Integer.valueOf(noClasses).floatValue();  //calculate average number of operation per class
//            }
//            
//            extractAttributes.append(" Total Number of classes =  " + noClasses + "\n");
//            extractAttributes.append(" Total Number of attributes =  " + noAttr + "\n");
//            extractAttributes.append(" Average number of attribute per class =  " + avgAttrCls + "\n");
//            extractAttributes.append(" Total Number of operation =  " + noOps + "\n");
//            extractAttributes.append(" Maximum (Highest) Number of operation per class =  " + maxNumOps + "\n");
//            extractAttributes.append(" Average number of operation per class =  " + avgOpsCls + "\n");
//            extractAttributes.append(" \n Total Number of outgoing dependency =  " + noDepOut + "\n");
//            extractAttributes.append(" Total Number of incoming dependency =  " + noDepIn + "\n");
//            
//            relationshipMetrics (xmiFile);
//    }                                       
//
//   
//    private void relationshipMetrics (String xmiFileSend){
//        int count = 0;
//        int noClasses = 0;
//        int noAssociation = 0;
//        float avgAssocCls = 0;
//        boolean twoDirectedRel = false;
//        
//        String xmiFile = xmiFileSend;
//        CSVReader csvReader = null;
//        metricsDisplay.setLineWrap(true);
//        
//        String csvFilename = "";
//        //csvFilename = csvFileName.getText();
//        String [] row = null;
//        
//        relationshipReader (xmiFile);       // generate relationship metrics csv
//        csvFilename = "dataRM_Class_Assoc.csv";
//        
//        try {
//            List<String> relListLocal = new ArrayList<>();
//
//            if (csvFilename.isEmpty() == false) {
//                try {
//                    csvReader = new CSVReader (new FileReader(csvFilename));
//                    try {
//                        row = csvReader.readNext();
//                    } catch (IOException ex) {
//                        Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
//                    }
//                } catch (FileNotFoundException ex) {
//                    Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
//                }
//      
//                while ((row = csvReader.readNext()) != null){
//                  for (int i = 1; i < row.length; i++){
//                      noAssociation = noAssociation + Integer.parseInt(row[i]); 
//                      if (Integer.parseInt(row[i]) > 1){
//                        twoDirectedRel = true;    
//                      } 
//                  } count++;
//                }
//                noClasses = count;
//                
//                if (noClasses > 0 && noAssociation > 0){
//                  avgAssocCls = Integer.valueOf(noAssociation).floatValue() / Integer.valueOf(noClasses).floatValue();;    
//                }
//                
//            }
//                             
//            try {
//                csvReader.close();
//            } catch (IOException ex) {
//                Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
//                }
//            } catch (IOException ex) {
//            Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
//            }
//                     
//            
//        extractAttributes.append(" Total Number of association =  " + noAssociation + "\n");
//        extractAttributes.append(" Average Number of association per class =  " + avgAssocCls + "\n");
//        extractAttributes.append(" Existence of two association directed to one class is " + twoDirectedRel + "\n");
////            extractAttributes.append(" Total Number of operation =  " + noOps + "\n");
////            extractAttributes.append(" Maximum (Highest) Number of operation per class =  " + maxNumOps + "\n");
////            extractAttributes.append(" Average number of operation per class =  " + avgOpsCls + "\n");
////            extractAttributes.append(" Total Number of outgoing dependency =  " + noDepOut + "\n");
////            extractAttributes.append(" Total Number of incoming dependency =  " + noDepIn + "\n");
//}
//    
//    private void relationshipReader (String xmiFileSend){
//        String xmiFile = xmiFileSend;    
//        String command = "java -jar SDMetrics.jar -xmi " +  xmiFile  + " -relmat -f csv data";
//        Process process = null;
//
//        try {
//                String s;
//                process = Runtime.getRuntime().exec(command); 
//                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
//                while((s=bufferedReader.readLine()) != null)
//                    System.out.println(s);
//                process.waitFor();
//            } catch (IOException ex) {
//                Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
//            }   catch (InterruptedException ex) {
//                    Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
//            }   
//    }
//    
//    private void classMetricsReader (String xmiFileSend){
//        
//        String command = "java -jar SDMetrics.jar -xmi " +  xmiFilename.getText()  + " -filter #.java -filter #.javax -filter #.org.xml -f csv data";
//        Process process = null;
//        try {
//            String s;
//            process = Runtime.getRuntime().exec(command); 
//            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
//            while((s=bufferedReader.readLine()) != null)
//            System.out.println(s);
//            process.waitFor();
//        } catch (IOException ex) {
//            Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
//        }   catch (InterruptedException ex) {
//            Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
//        }
//    }
 */   
    
    private void saveTextActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveTextActionPerformed
        // TODO add your handling code here:
    PrintStream out = null;
    String textFileStr = "";
    
    FileFilter filters;
    JFileChooser fileChooser = new JFileChooser();
            
    filters = new csvExtendName();
    fileChooser.setFileFilter(filters);
       int returnVal = fileChooser.showSaveDialog(this);
       if (returnVal == JFileChooser.APPROVE_OPTION) {
           File file = fileChooser.getSelectedFile();           
           textFileStr = file.getAbsolutePath();
           csvFileName.setText(textFileStr);
       } else {
           System.out.println("File access cancelled by user.");
           }    
    
      if (textFileStr.isEmpty() == false){
          try {
            try {
                out = new PrintStream(new FileOutputStream(csvFileName.getText()));
            } catch (FileNotFoundException ex) {
                Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
            }
            if (metricsDisplay.getText().isEmpty() == false){
                out.print(metricsDisplay.getText());
            }
        }
        finally {
            if (out != null) out.close();
            }
        }
       
    }//GEN-LAST:event_saveTextActionPerformed

    private void clearBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_clearBtnActionPerformed
        // TODO add your handling code here:
        metricsDisplay.setText(null);
        extractAttributes.setText(null);        
    }//GEN-LAST:event_clearBtnActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        CSVReader csvReader = null;
        metricsDisplay.setLineWrap(true);
        
        String csvFilename = "";
        csvFilename = csvFileName.getText();
        String []row = null;
        
//        try {
            // TODO add your handling code here:            
            List<String> classListLocal = new ArrayList<>();
            
            if (csvFilename.isEmpty() == false) {
                try {
                    csvReader = new CSVReader (new FileReader(csvFilename));
                    try {
                        row = csvReader.readNext();
                    } catch (IOException ex) {
                        Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
                    }
                } catch (FileNotFoundException ex) {
                    Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
                }

            int count = 0;
            String [][] ins = null;
                try {
                    while ((row = csvReader.readNext()) != null){
                        //int lastDotIndex = row[1].lastIndexOf(".") + 1;
                        //row[0] = row[0].substring(lastDotIndex);
                        if(ins == null){
                            ins[0][0] = row[1].substring(0);
                            ins[0][1] = row[2].substring(0);
                            ins[0][2] = "1";
                        } else {
                            int count2 = 0;
                            while (count <= row.length){
                                if (ins[count][0].substring(0) == row[1] && ins[count][1].substring(0) == row[2]){
                                    ins[count][2] = Integer.toString(Integer.parseInt(ins[count][2].substring(0)) + 1);
                                } else {
                                    ins[count][0] = row[1].substring(0);
                                    ins[count][1] = row[2].substring(0);
                                    ins[count][2] = "1";
                                    System.out.println("Test");
                                }
                            count2++;
                            }
                            //classListLocal.add(row[1].substring(0) + " " +  row[2].substring(0) + " " + );
                            //System.out.println(count + " name :" + classListLocal.get(count));
                        } 
                       
                        //classnamesText.append(classListLocal.get(count));
                        /*String stringa1 = row[1];//classListLocal.get(count);
                        System.out.println("Stringa1 :" + stringa1);               //printing the data
                        int dotIndex = stringa1.lastIndexOf(".");
                        System.out.println("dotIndex : " + dotIndex);
                        int stringLength = stringa1.length();
                        char[] char_arr = stringa1.toCharArray();
                        int count2 = dotIndex + 1;
                        System.out.println("count2 : " + count2);
                        
                        while (count2 < stringLength){
                         // if uppercase and character after is lowercase
                            System.out.println("count2 : " + count2);
                            if(Character.isUpperCase(char_arr[count2]) == true && count2 != (stringLength - 1) &&
                               Character.isLowerCase(char_arr[count2 + 1]) == true  ) {
                               classnamesText.append(" " + Character.toString(char_arr[count2]));
                               }
                             // if uppercase, not first character and character before lower case, add space
                             else if(Character.isUpperCase(char_arr[count2]) == true && Character.isLowerCase(char_arr[count2 - 1]) == true) {
                               classnamesText.append(" " + Character.toString(char_arr[count2]));
                               }
                              // if uppercase and character before also uppercase
                             else if(Character.isUpperCase(char_arr[count2]) == true && Character.isUpperCase(char_arr[count2 - 1]) == true) {
                               classnamesText.append(Character.toString(char_arr[count2]));
                               }
                              // if lowercase
                             else if (Character.isLowerCase(char_arr[count2]) == true) {
                                classnamesText.append(Character.toString(char_arr[count2]));
                                }
                                else
                                   classnamesText.append(" " + Character.toString(char_arr[count2]));
                                count2++;
                                }*/
                          count++;
                          }              
                } catch (IOException ex) {
                    Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
                }
            }

            try {
                csvReader.close();
            } catch (IOException ex) {
                Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
                }
            //} 
           // catch (IOException ex) {
           //  Logger.getLogger(TextExtractor1.class.getName()).log(Level.SEVERE, null, ex);
           // }
            //} 
           // catch (IOException ex) {
           //  Logger.getLogger(TextExtractor1.class.getName()).log(Level.SEVERE, null, ex);
           // }
    }//GEN-LAST:event_jButton1ActionPerformed

    private void csvFileNameActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_csvFileNameActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_csvFileNameActionPerformed

    private void xmiFilenameActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_xmiFilenameActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_xmiFilenameActionPerformed

    private void readClassMetricsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_readClassMetricsActionPerformed
        String command = "java -jar SDMetrics.jar -xmi " +  xmiFilename.getText()  + " -filter #.java -filter #.javax -filter #.org.xml -f csv data";
        Process process = null;
        try {
            String s;
            process = Runtime.getRuntime().exec(command);
            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            while((s=bufferedReader.readLine()) != null)
            System.out.println(s);
            process.waitFor();
        } catch (IOException ex) {
            Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
        }   catch (InterruptedException ex) {
            Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_readClassMetricsActionPerformed

    private void listMetricsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_listMetricsActionPerformed
        String element = "";
        int noClass = 0;            // number of classes
        int noAttribute = 0;        // number of attributes
        int noOps = 0;              // number of operation
        float avgOpsClass = 0;      // average number of operation per class
        int noAssoc = 0;            // total number of association
        int noGeneralization = 0;   // total number of generalization
        int noRealization = 0;      // total number of realization
        int noParameter = 0;        // total number of parameter
        int maxAttribute = 0;       // maximum (highest) number of attribute per class
        int maxOperation = 0;       // maximum (highest) number of operation per class
        float avgAssocCls = 0;      // average number of association per class
        int noAggregation = 0;      // number of aggregation
        float avgAttrClass = 0;     // average number of attribute per class

        metricsDisplay.setText(null);

        File xmiFile = new File(xmiFilename.getText());
        String metamodel = "";
        String modelTrans = "";

        // UML and XMI transformation selection
        XMIVersionExtractor ver = new XMIVersionExtractor(xmiFile);
        System.out.println("xmiVersion = " + ver.getVersion());

        if (ver.getVersion().startsWith("1.")){
            metamodel = "metamodel.xml";
            // xmi ver = 1.0
            if (ver.getVersion().equals("1.0")){
                modelTrans = "xmiTrans1_0.xml";
            } else // xmi ver = 1.x
            modelTrans = "xmiTrans1_1.xml";
        } else {
            metamodel = "metamodel2.xml";
            modelTrans = "xmiTrans2_0.xml";
        }
        System.out.println("Using files " + metamodel + " and " + modelTrans);

        XMIMetricsExtractor oper = new XMIMetricsExtractor(xmiFile, metamodel, modelTrans);
        int noCL = oper.getNoCls();
        System.out.println("Number of class = " + noCL + "\n");

        // No. Class - calculate number of classes
        element = "class";
        noClass = metricsCollector (xmiFilename.getText(), metamodel, modelTrans, element);
        metricsDisplay.append("Number of " + element + " = " + noClass + "\n");
        System.out.println("Number of " + element + " = " + noClass + "\n");

        // No. Attribute - calculate number of attributes
        element = "ownedattributes";
        noAttribute = numAttr (xmiFilename.getText(), metamodel, modelTrans, element);
        metricsDisplay.append("Number of " + element + " = " + noAttribute + "\n");
        System.out.println("Number of " + element + " = " + noAttribute + "\n");

        // calculate average number of attribute per class
        element = "Average number of attribute per class";
        if (noAttribute > 0 && noClass > 0){
            avgAttrClass = (float)noAttribute/(float)noClass;
        }
        metricsDisplay.append(element + " = " + avgAttrClass + "\n");
        System.out.println(element + " = " + avgAttrClass + "\n");

        // No. Operation - calculate number of operation
        element = "operation";
        noOps = metricsCollector (xmiFilename.getText(), metamodel, modelTrans, element);
        metricsDisplay.append("Number of " + element + " = " + noOps + "\n");
        System.out.println("Number of " + element + " = " + noOps + "\n");

        // calculate average number of operation per class
        element = "Average number of operation per class";
        if (noOps > 0 && noClass > 0){
            avgOpsClass = (float)noOps/(float)noClass;
        }
        metricsDisplay.append(element + " = " + avgOpsClass + "\n");
        System.out.println(element + " = " + avgOpsClass + "\n");

        // F14 = maximum (highest) number of attribute per class
        //element = "ownedattributes"; // for XMI 2.x
        element = "attribute";
        maxAttribute = maxAttrOps (xmiFilename.getText(), metamodel, modelTrans, element);
        metricsDisplay.append("Maximum number of attributes per class = " + maxAttribute + "\n");
        System.out.println("Maximum number of attributes per class = " + maxAttribute + "\n");

        // F15 = calculate maximum (highest) number of operation per class
        //element = "ownedoperations"; // for xmi 2.x
        element = "operation"; // for xmi 1.x
        maxOperation = maxAttrOps (xmiFilename.getText(), metamodel, modelTrans, element);
        metricsDisplay.append("Maximum number of operation per class = " + maxOperation + "\n");
        System.out.println("Maximum number of operation per class = " + maxOperation + "\n");

        //calculate number of parameter
        //element = "ownedparameters"; // for xmi 2.x
        element = "parameter";
        noParameter = metricsCollector (xmiFilename.getText(), metamodel, modelTrans, element);
        metricsDisplay.append("Number of " + element + " = " + noParameter + "\n\n");
        System.out.println("Number of " + element + " = " + noParameter + "\n");

        //calculate number of association
        element = "association";
        noAssoc = metricsCollector (xmiFilename.getText(), metamodel, modelTrans, element);
        metricsDisplay.append("Number of " + element + " = " + noAssoc + "\n");
        System.out.println("Number of " + element + " = " + noAssoc + "\n");

        // calculate average number of association per class
        element = "Average number of association per class";
        if (noAssoc > 0 && noClass > 0){
            avgAssocCls = (float)noAssoc/(float)noClass;
        }
        metricsDisplay.append(element + " = " + avgAssocCls + "\n");
        System.out.println(element + " = " + avgAssocCls + "\n");

        //calculate number of generalization
        element = "generalization";
        noGeneralization = metricsCollector (xmiFilename.getText(), metamodel, modelTrans, element);
        metricsDisplay.append("Number of " + element + " = " + noGeneralization + "\n");
        System.out.println("Number of " + element + " = " + noGeneralization + "\n");

        //calculate number of realization
        element = "realization";
        noRealization = metricsCollector (xmiFilename.getText(), metamodel, modelTrans, element);
        metricsDisplay.append("Number of " + element + " = " + noRealization + "\n");
        System.out.println("Number of " + element + " = " + noRealization + "\n");

        //calculate number of aggregation
        element = "property";
        noAggregation = countAggregation (xmiFilename.getText(), metamodel, modelTrans, element);
        metricsDisplay.append("Number of Aggregation = " + noAggregation + "\n");
        System.out.println("Number of Aggregation = " + noAggregation + "\n");
    }//GEN-LAST:event_listMetricsActionPerformed

    private void btnListMetricsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnListMetricsActionPerformed
        File xmiFile = new File(xmiFilename.getText());
        String metamodel = "";
        String modelTrans = "";

        // UML and XMI transformation selection
        XMIVersionExtractor ver = new XMIVersionExtractor(xmiFile);
        System.out.println("xmiVersion = " + ver.getVersion());

        if (ver.getVersion().startsWith("1.")){
            metamodel = "metamodel.xml";
            // xmi ver = 1.0
            if (ver.getVersion().equals("1.0")){
                modelTrans = "xmiTrans1_0.xml";
            } else // xmi ver = 1.x
            modelTrans = "xmiTrans1_1.xml";
        } else {
            metamodel = "metamodel2.xml";
            modelTrans = "xmiTrans2_0.xml";
        }
        System.out.println("Using files " + metamodel + " and " + modelTrans);

        XMIMetricsExtractor xmiExtractor = new XMIMetricsExtractor(xmiFile, metamodel, modelTrans);

        System.out.println("F01 = Number of class = " + xmiExtractor.getNoCls());
        System.out.println("F02 = Number of operation = " + xmiExtractor.getNoOper());
        System.out.println("F03 = Number of attribute = " + xmiExtractor.getNoAttr());
        System.out.println("F04 = Number of parameter = " + xmiExtractor.getNoPara());
        System.out.println("F05 = Existence of parameter = " + xmiExtractor.isExtOperPara());
        System.out.println("F06 = Number of association = " + xmiExtractor.getNoAssociation());
        System.out.println("F07 = Existence of different association type = " + xmiExtractor.getNoAssocType());
        System.out.println("F08 = Average number of attribute per class = " + xmiExtractor.getAvgAttrCls());
        System.out.println("F09 = Average number of operations per class = " + xmiExtractor.getAvgOperCls());
        System.out.println("F10 = Average number of associations per class = " + xmiExtractor.getAvgAssocCls());
        System.out.println("F11 = Average number of parameters per operations = " + xmiExtractor.getAvgParaOper());
        System.out.println("F12 = Maximum number of attributes per class = " + xmiExtractor.getMaxAttrCls());
        System.out.println("F13 = Maximum number of operations per class = " + xmiExtractor.getMaxOperCls());
    }//GEN-LAST:event_btnListMetricsActionPerformed

    private void umlVersionSelActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_umlVersionSelActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_umlVersionSelActionPerformed
  
    private void testWriter() throws IOException{
        String csv = "C:\\output2.csv";
        String test1 = "Test 1";
        String test2 = "Test 2";
        try (CSVWriter writer = new CSVWriter(new FileWriter(csv))) {
            List<String[]> data = new ArrayList<>();
            data.add(new String[] {"India", test1});
            data.add(new String[] {"United States", "Washington D.C"});
            data.add(new String[] {test2, "Berlin"});
     
            writer.writeAll(data);
        }
    }
    
    private int metricsCollector(String xmiFileName, String metamodelURLfile, String xmiTransURLfile, String reqMetrics){
        String metaModelURL = metamodelURLfile;//sdmetrics";  // metamodel definition to use
	String xmiTransURL = xmiTransURLfile;   // XMI tranformations to use
	String xmiFile = xmiFileName; // XMI file with the UML model
        int elementCount = 0;
           
        metricsDisplay.setLineWrap(true);
        if (xmiFile.isEmpty()== false) {
            XMLParser parser = null;
            try {
                parser = new XMLParser();
                MetaModel metaModel = new MetaModel();
                
                parser.parse(metaModelURL, metaModel.getSAXParserHandler());
                
                XMITransformations trans=new XMITransformations(metaModel);
                parser.parse(xmiTransURL, trans.getSAXParserHandler());
                
                Model model = new Model(metaModel);
                XMIReader xmiReader = new XMIReader(trans, model);
                parser.parse(xmiFile, xmiReader);
                
                String[] filters = { "#.java", "#.javax", "#.org.xml" };
                model.setFilter(filters, false, true);

                //iterate over all model element types in the metamodel
                for (MetaModelElement type : metaModel) {
                    //System.out.println("Elements of type: " + type.getName());
                    // iterate over all model elements of the current type
                    List<ModelElement> elements = model.getAcceptedElements(type);
                    for (ModelElement me : elements) {
                        if (me.getType().getName().matches(reqMetrics)){
                          elementCount++;    
                        }
                    }
                }
            } catch (Exception ex) {
                Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
                System.out.println("Error occured when parsing the file " + xmiFile);
            }
        }
        return elementCount;
    }

        private int maxAttrOps(String xmiFileName, String metamodelURLfile, String xmiTransURLfile, String reqAttrOps){
        String metaModelURL = metamodelURLfile;//sdmetrics";  // metamodel definition to use
	String xmiTransURL = xmiTransURLfile;   // XMI tranformations to use
	String xmiFile = xmiFileName; // XMI file with the UML model
           
        extractAttributes.setLineWrap(true);

        XMLParser parser = null;
        try {
            parser = new XMLParser();
        } catch (Exception ex) {
            Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
        }
        MetaModel metaModel = new MetaModel();
        try {
            parser.parse(metaModelURL, metaModel.getSAXParserHandler());
        } catch (Exception ex) {
            Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
        }

        XMITransformations trans=new XMITransformations(metaModel);
        try {
            parser.parse(xmiTransURL, trans.getSAXParserHandler());
        } catch (Exception ex) {
            Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
        }

        Model model = new Model(metaModel);
        XMIReader xmiReader = new XMIReader(trans, model);
        try {
            parser.parse(xmiFile, xmiReader);
        } catch (Exception ex) {
            Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
        }

        String[] filters = { "#.java", "#.javax", "#.org.xml" };
        model.setFilter(filters, false, true);

        int elementMax =0;
        int count = 0;
        //iterate over all model element types in the metamodel
        for (MetaModelElement type : metaModel) {
            //System.out.println("Elements of type: " + type.getName());
            if (type.getName().matches("class")){        
                // iterate over all model elements of the current type
                List<ModelElement> elements = model.getAcceptedElements(type);
                for (ModelElement me : elements) {
                    //System.out.println("  Class: " + me.getFullName() + " ");
                    Collection<ModelElement> ownedElements = me.getOwnedElements();
                    if (ownedElements != null){
                        for (ModelElement modelE:ownedElements){
                            if (modelE.getType().getName().matches(reqAttrOps)){
                                count ++;
                                //System.out.println(reqAttrOps + ":" + modelE.getName());
                            }
                        }
                        if (count != 0 && elementMax < count)
                            elementMax = count;
                        count =0;
                    }    
                }
            }	
        }
        return elementMax;
    }
    
    private int numAttr(String xmiFileName, String metamodelURLfile, String xmiTransURLfile, String reqAttrOps){
        String metaModelURL = metamodelURLfile;//sdmetrics";  // metamodel definition to use
	String xmiTransURL = xmiTransURLfile;   // XMI tranformations to use
	String xmiFile = xmiFileName; // XMI file with the UML model
        int elementCount = 0;
           
        extractAttributes.setLineWrap(true);

        XMLParser parser = null;
        try {
            parser = new XMLParser();
        } catch (Exception ex) {
            Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
        }
        MetaModel metaModel = new MetaModel();
        try {
            parser.parse(metaModelURL, metaModel.getSAXParserHandler());
        } catch (Exception ex) {
            Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
        }

        XMITransformations trans=new XMITransformations(metaModel);
        try {
            parser.parse(xmiTransURL, trans.getSAXParserHandler());
        } catch (Exception ex) {
            Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
        }

        Model model = new Model(metaModel);
        XMIReader xmiReader = new XMIReader(trans, model);
        try {
            parser.parse(xmiFile, xmiReader);
        } catch (Exception ex) {
            Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
        }

        String[] filters = { "#.java", "#.javax", "#.org.xml" };
        model.setFilter(filters, false, true);

        //iterate over all model element types in the metamodel
        for (MetaModelElement type : metaModel) {
                System.out.println("Elements of type: " + type.getName());
                if (type.getName().matches("attribute")){        
                // iterate over all model elements of the current type
                List<ModelElement> elements = model.getAcceptedElements(type);
                for (ModelElement me : elements) {
                        System.out.println("  Element: " + me.getFullName() + " ");
                        elementCount++;
                        // write out the value of each attribute of the element
//                        Collection<String> attributeNames = type.getAttributeNames();
//                        for (String attr : attributeNames) {
//                            if (attr.matches("ownedattributes")){
//                                System.out.println("     Attribute '" + me.getSetAttribute(attr).size());
//                                elementCount = elementCount + me.getSetAttribute(attr).size();
//                                }
//                            }
                        }
                }
            }	
        return elementCount;
    }    

    private int countAggregation(String xmiFileName, String metamodelURLfile, String xmiTransURLfile, String reqAttrOps){
        String metaModelURL = metamodelURLfile;//sdmetrics";  // metamodel definition to use
	String xmiTransURL = xmiTransURLfile;   // XMI tranformations to use
	String xmiFile = xmiFileName; // XMI file with the UML model
        int numAggregation = 0;
           
        extractAttributes.setLineWrap(true);

        XMLParser parser = null;
        try {
            parser = new XMLParser();
        } catch (Exception ex) {
            Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
        }
        MetaModel metaModel = new MetaModel();
        try {
            parser.parse(metaModelURL, metaModel.getSAXParserHandler());
        } catch (Exception ex) {
            Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
        }

        XMITransformations trans=new XMITransformations(metaModel);
        try {
            parser.parse(xmiTransURL, trans.getSAXParserHandler());
        } catch (Exception ex) {
            Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
        }

        Model model = new Model(metaModel);
        XMIReader xmiReader = new XMIReader(trans, model);
        try {
            parser.parse(xmiFile, xmiReader);
        } catch (Exception ex) {
            Logger.getLogger(FeatureExtractor.class.getName()).log(Level.SEVERE, null, ex);
        }

        String[] filters = { "#.java", "#.javax", "#.org.xml" };
        model.setFilter(filters, false, true);

        //iterate over all model element types in the metamodel
        for (MetaModelElement type : metaModel) {
                System.out.println("Elements of type: " + type.getName());
                if (type.getName().matches(reqAttrOps)){        
                // iterate over all model elements of the current type
                List<ModelElement> elements = model.getAcceptedElements(type);
                for (ModelElement me : elements) {
                        //System.out.println("  Element: " + me.getFullName() + " ");

                        // write out the value of each attribute of the element
                        Collection<String> attributeNames = type.getAttributeNames();
                        for (String attr : attributeNames) {
                            if (attr.matches("aggregation")){
                                if (me.getPlainAttribute(attr).matches("shared")){
                                    numAggregation++;
                                }
                                //System.out.println("     Attribute '" + me.getPlainAttribute(attr));
                                //System.out.println("test");
                                //if (elementMax < me.getSetAttribute(attr).size()){
                                //    elementMax = me.getSetAttribute(attr).size();
                                }
                            }
//                                System.out.print("     Attribute '" + attr);
//                                if (type.isSetAttribute(attr))
//                                        System.out.println("' has set value "
//                                                        + me.getSetAttribute(attr));
//                                else if (type.isRefAttribute(attr)) {
//                                        System.out.print("' references ");
//                                        ModelElement referenced = me.getRefAttribute(attr);
//                                        System.out.println((referenced == null) ? "nothing"
//                                                        : referenced.getFullName());
//                                } else
//                                        System.out.println("' has value: "
//                                                        + me.getPlainAttribute(attr));
                        }
                }
            }	
        return numAggregation;
    }
    
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(FeatureExtractor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(FeatureExtractor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(FeatureExtractor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(FeatureExtractor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new FeatureExtractor().setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem aboutMenuItem;
    private javax.swing.JButton btnListMetrics;
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.JButton chooseFileBtn;
    private javax.swing.JButton clearBtn;
    private javax.swing.JMenuItem contentsMenuItem;
    private javax.swing.JMenuItem copyMenuItem;
    private javax.swing.JButton csvFile;
    private javax.swing.JTextField csvFileName;
    private javax.swing.JMenuItem cutMenuItem;
    private javax.swing.JMenuItem deleteMenuItem;
    private javax.swing.JMenu editMenu;
    private javax.swing.JMenuItem exitMenuItem;
    private javax.swing.JTextArea extractAttributes;
    private javax.swing.JMenu fileMenu;
    private javax.swing.JScrollPane fullClassnameText;
    private javax.swing.JMenu helpMenu;
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JButton listMetrics;
    private javax.swing.JMenuBar menuBar;
    private javax.swing.JTextArea metricsDisplay;
    private javax.swing.JMenuItem openMenuItem;
    private javax.swing.JMenuItem pasteMenuItem;
    private javax.swing.JButton readCSV;
    private javax.swing.JButton readClassMetrics;
    private javax.swing.JMenuItem saveAsMenuItem;
    private javax.swing.JMenuItem saveMenuItem;
    private javax.swing.JButton saveText;
    private javax.swing.JPanel textPanel;
    private javax.swing.JComboBox umlVersionSel;
    private javax.swing.JTextField xmiFilename;
    private javax.swing.JComboBox xmiVerSel;
    // End of variables declaration//GEN-END:variables
}
